{
  "version": 3,
  "sources": ["../../result/convert.ts"],
  "sourcesContent": ["export interface Unit {\n  name: {\n    singular: string;\n    plural: string;\n  };\n  to_anchor: number;\n  anchor_shift?: number;\n}\n\nexport interface Conversion<\n  TMeasures extends string,\n  TSystems extends string,\n  TUnits extends string\n> {\n  abbr: TUnits;\n  measure: TMeasures;\n  system: TSystems;\n  unit: Unit;\n}\n\nexport interface UnitDescription {\n  abbr: string;\n  measure: string;\n  system: string;\n  singular: string;\n  plural: string;\n}\n\ntype TransformFunc = (value: number) => number;\n\nexport interface Anchor {\n  ratio?: number;\n  transform?: TransformFunc;\n}\n\nexport interface Measure<TSystems extends string, TUnits extends string> {\n  systems: Partial<Record<TSystems, Partial<Record<TUnits, Unit>>>>;\n  anchors?: Partial<Record<TSystems, Partial<Record<TSystems, Anchor>>>>;\n}\n\nexport interface BestResult {\n  val: number;\n  unit: string;\n  singular: string;\n  plural: string;\n}\n\n/**\n * Represents a conversion path\n */\nexport class Converter<\n  TMeasures extends string,\n  TSystems extends string,\n  TUnits extends string\n> {\n  private val = 0;\n  private destination: Conversion<TMeasures, TSystems, TUnits> | null = null;\n  private origin: Conversion<TMeasures, TSystems, TUnits> | null = null;\n  private measureData: Record<TMeasures, Measure<TSystems, TUnits>>;\n\n  constructor(\n    measures: Record<TMeasures, Measure<TSystems, TUnits>>,\n    value?: number\n  ) {\n    if (typeof value === 'number') {\n      this.val = value;\n    }\n\n    if (typeof measures !== 'object') {\n      throw new Error('Measures cannot be blank');\n    }\n\n    this.measureData = measures;\n  }\n\n  /**\n   * Lets the converter know the source unit abbreviation\n   */\n  from(from: TUnits): this {\n    if (this.destination != null)\n      throw new Error('.from must be called before .to');\n\n    this.origin = this.getUnit(from);\n\n    if (this.origin == null) {\n      this.throwUnsupportedUnitError(from);\n    }\n\n    return this;\n  }\n\n  /**\n   * Converts the unit and returns the value\n   */\n  to(to: TUnits): number {\n    if (this.origin == null) throw new Error('.to must be called after .from');\n\n    this.destination = this.getUnit(to);\n\n    if (this.destination == null) {\n      this.throwUnsupportedUnitError(to);\n    }\n\n    const destination = this.destination as Conversion<\n      TMeasures,\n      TSystems,\n      TUnits\n    >;\n    const origin = this.origin as Conversion<TMeasures, TSystems, TUnits>;\n\n    // Don't change the value if origin and destination are the same\n    if (origin.abbr === destination.abbr) {\n      return this.val;\n    }\n\n    // You can't go from liquid to mass, for example\n    if (destination.measure != origin.measure) {\n      throw new Error(\n        `Cannot convert incompatible measures of ${destination.measure} and ${origin.measure}`\n      );\n    }\n\n    /**\n     * Convert from the source value to its anchor inside the system\n     */\n    let result: number = this.val * origin.unit.to_anchor;\n\n    /**\n     * For some changes it's a simple shift (C to K)\n     * So we'll add it when convering into the unit (later)\n     * and subtract it when converting from the unit\n     */\n    if (origin.unit.anchor_shift) {\n      result -= origin.unit.anchor_shift;\n    }\n\n    /**\n     * Convert from one system to another through the anchor ratio. Some conversions\n     * aren't ratio based or require more than a simple shift. We can provide a custom\n     * transform here to provide the direct result\n     */\n    if (origin.system != destination.system) {\n      const measure = this.measureData[origin.measure];\n\n      const anchors = measure.anchors;\n      if (anchors == null) {\n        throw new Error(\n          `Unable to convert units. Anchors are missing for \"${origin.measure}\" and \"${destination.measure}\" measures.`\n        );\n      }\n\n      const anchor: Partial<Record<TSystems, Anchor>> | undefined =\n        anchors[origin.system];\n      if (anchor == null) {\n        throw new Error(\n          `Unable to find anchor for \"${origin.measure}\" to \"${destination.measure}\". Please make sure it is defined.`\n        );\n      }\n\n      const transform: unknown = anchor[destination.system]?.transform;\n      const ratio: unknown = anchor[destination.system]?.ratio;\n\n      if (typeof transform === 'function') {\n        result = transform(result);\n      } else if (typeof ratio === 'number') {\n        result *= ratio;\n      } else {\n        throw new Error(\n          'A system anchor needs to either have a defined ratio number or a transform function.'\n        );\n      }\n    }\n\n    /**\n     * This shift has to be done after the system conversion business\n     */\n    if (destination.unit.anchor_shift) {\n      result += destination.unit.anchor_shift;\n    }\n\n    /**\n     * Convert to another unit inside the destination system\n     */\n    return result / destination.unit.to_anchor;\n  }\n\n  /**\n   * Converts the unit to the best available unit.\n   */\n  toBest(options?: {\n    exclude?: TUnits[];\n    cutOffNumber?: number;\n    system?: TSystems;\n  }): BestResult | null {\n    if (this.origin == null)\n      throw new Error('.toBest must be called after .from');\n\n    const isNegative = this.val < 0;\n\n    let exclude: TUnits[] = [];\n    let cutOffNumber = isNegative ? -1 : 1;\n    let system = this.origin.system;\n\n    if (typeof options === 'object') {\n      exclude = options.exclude ?? [];\n      cutOffNumber = options.cutOffNumber ?? cutOffNumber;\n      system = options.system ?? this.origin.system;\n    }\n\n    let best: BestResult | null = null;\n    /**\n      Looks through every possibility for the 'best' available unit.\n      i.e. Where the value has the fewest numbers before the decimal point,\n      but is still higher than 1.\n    */\n    for (const possibility of this.possibilities()) {\n      const unit = this.describe(possibility);\n      const isIncluded = exclude.indexOf(possibility) === -1;\n\n      if (isIncluded && unit.system === system) {\n        const result = this.to(possibility);\n        if (isNegative ? result > cutOffNumber : result < cutOffNumber) {\n          continue;\n        }\n        if (\n          best === null ||\n          (isNegative\n            ? result <= cutOffNumber && result > best.val\n            : result >= cutOffNumber && result < best.val)\n        ) {\n          best = {\n            val: result,\n            unit: possibility,\n            singular: unit.singular,\n            plural: unit.plural,\n          };\n        }\n      }\n    }\n\n    return best;\n  }\n  /**\n   * Finds the unit\n   */\n  getUnit(abbr: TUnits): Conversion<TMeasures, TSystems, TUnits> | null {\n    const found = null;\n\n    for (const [measureName, measure] of Object.entries(this.measureData)) {\n      for (const [systemName, system] of Object.entries(\n        (measure as Measure<TSystems, TUnits>).systems\n      )) {\n        for (const [testAbbr, unit] of Object.entries(\n          system as Partial<Record<TUnits, Unit>>\n        )) {\n          if (testAbbr == abbr) {\n            return {\n              abbr: abbr as TUnits,\n              measure: measureName as TMeasures,\n              system: systemName as TSystems,\n              unit: unit as Unit,\n            };\n          }\n        }\n      }\n    }\n\n    return found;\n  }\n\n  /**\n   * An alias for getUnit\n   */\n  describe(abbr: TUnits): UnitDescription | never {\n    const result = this.getUnit(abbr);\n\n    if (result != null) {\n      return this.describeUnit(result);\n    }\n\n    this.throwUnsupportedUnitError(abbr);\n  }\n\n  private describeUnit(\n    unit: Conversion<TMeasures, TSystems, TUnits>\n  ): UnitDescription {\n    return {\n      abbr: unit.abbr,\n      measure: unit.measure,\n      system: unit.system,\n      singular: unit.unit.name.singular,\n      plural: unit.unit.name.plural,\n    };\n  }\n\n  /**\n   * Detailed list of all supported units\n   *\n   * If a measure is supplied the list will only contain\n   * details about that measure. Otherwise the list will contain\n   * details abaout all measures.\n   *\n   * However, if the measure doesn't exist, an empty array will be\n   * returned\n   *\n   */\n  list(measureName?: TMeasures): UnitDescription[] | never {\n    const list = [];\n\n    if (measureName == null) {\n      for (const [name, measure] of Object.entries(this.measureData)) {\n        for (const [systemName, units] of Object.entries(\n          (measure as Measure<TSystems, TUnits>).systems\n        )) {\n          for (const [abbr, unit] of Object.entries(\n            units as Partial<Record<TUnits, Unit>>\n          )) {\n            list.push(\n              this.describeUnit({\n                abbr: abbr as TUnits,\n                measure: name as TMeasures,\n                system: systemName as TSystems,\n                unit: unit as Unit,\n              })\n            );\n          }\n        }\n      }\n    } else if (!(measureName in this.measureData)) {\n      throw new Error(`Meausre \"${measureName}\" not found.`);\n    } else {\n      const measure = this.measureData[measureName];\n      for (const [systemName, units] of Object.entries(\n        (measure as Measure<TSystems, TUnits>).systems\n      )) {\n        for (const [abbr, unit] of Object.entries(\n          units as Partial<Record<TUnits, Unit>>\n        )) {\n          list.push(\n            this.describeUnit({\n              abbr: abbr as TUnits,\n              measure: measureName as TMeasures,\n              system: systemName as TSystems,\n              unit: unit as Unit,\n            })\n          );\n        }\n      }\n    }\n\n    return list;\n  }\n\n  private throwUnsupportedUnitError(what: string): never {\n    let validUnits: string[] = [];\n\n    for (const measure of Object.values(this.measureData)) {\n      for (const systems of Object.values(\n        (measure as Measure<TSystems, TUnits>).systems\n      )) {\n        validUnits = validUnits.concat(\n          Object.keys(systems as Record<TUnits, Unit>)\n        );\n      }\n    }\n\n    throw new Error(\n      `Unsupported unit ${what}, use one of: ${validUnits.join(', ')}`\n    );\n  }\n\n  /**\n   * Returns the abbreviated measures that the value can be\n   * converted to.\n   */\n  possibilities(forMeasure?: TMeasures): TUnits[] {\n    let possibilities: TUnits[] = [];\n    let list_measures: TMeasures[] = [];\n\n    if (typeof forMeasure == 'string') {\n      list_measures.push(forMeasure);\n    } else if (this.origin != null) {\n      list_measures.push(this.origin.measure);\n    } else {\n      list_measures = Object.keys(this.measureData) as TMeasures[];\n    }\n\n    for (const measure of list_measures) {\n      const systems = this.measureData[measure].systems;\n\n      for (const system of Object.values(systems)) {\n        possibilities = [\n          ...possibilities,\n          ...(Object.keys(system as Record<TUnits, Unit>) as TUnits[]),\n        ];\n      }\n    }\n\n    return possibilities;\n  }\n\n  /**\n   * Returns the abbreviated measures that the value can be\n   * converted to.\n   */\n  measures(): TMeasures[] {\n    return Object.keys(this.measureData) as TMeasures[];\n  }\n}\n\nexport default function <\n  TMeasures extends string,\n  TSystems extends string,\n  TUnits extends string\n>(\n  measures: Record<TMeasures, Measure<TSystems, TUnits>>\n): (value?: number) => Converter<TMeasures, TSystems, TUnits> {\n  return (value?: number) =>\n    new Converter<TMeasures, TSystems, TUnits>(measures, value);\n}\n"],
  "mappings": "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",
  "names": []
}
