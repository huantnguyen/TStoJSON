"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
const safe_stable_stringify_1 = __importDefault(require("safe-stable-stringify"));
const typescript_1 = __importDefault(require("typescript"));
const Utils_1 = require("./Utils");
class Context {
    constructor(reference, parentContext) {
        this.cacheKey = null;
        this.arguments = [];
        this.parameters = [];
        this.defaultArgument = new Map();
        this.ignoreLimits = false;
        this.isParameter = false;
        this.reference = reference;
        this.parentContext = parentContext;
    }
    pushArgument(argumentType) {
        this.arguments.push(argumentType);
        this.cacheKey = null;
    }
    pushParameter(parameterName) {
        this.parameters.push(parameterName);
    }
    setDefault(parameterName, argumentType) {
        this.defaultArgument.set(parameterName, argumentType);
    }
    getCacheKey(config) {
        var _a;
        if (this.cacheKey == null) {
            this.cacheKey = (0, safe_stable_stringify_1.default)([
                this.reference ? (0, Utils_1.getKey)(this.reference, this) : "",
                this.arguments.map((argument) => argument === null || argument === void 0 ? void 0 : argument.getId()),
                ((_a = this.parentContext) === null || _a === void 0 ? void 0 : _a.reference) &&
                    this.parentContext.reference.kind === typescript_1.default.SyntaxKind.ExpressionWithTypeArguments
                    ? typescript_1.default.SyntaxKind.ExpressionWithTypeArguments
                    : "",
                (0, Utils_1.hasLimitOptions)(config) && (0, Utils_1.ignoreLimits)(this) ? "recursion" : "",
            ]);
        }
        return this.cacheKey;
    }
    getArgument(parameterName) {
        const index = this.parameters.indexOf(parameterName);
        if ((index < 0 || !this.arguments[index]) && this.defaultArgument.has(parameterName)) {
            return this.defaultArgument.get(parameterName);
        }
        return this.arguments[index];
    }
    getParameters() {
        return this.parameters;
    }
    getArguments() {
        return this.arguments;
    }
    getReference() {
        return this.reference;
    }
    getParentContext() {
        return this.parentContext;
    }
    hasParentContext() {
        return this.parentContext !== undefined;
    }
    hasParentContextRecreance() {
        return this.parentContext !== undefined && this.parentContext.reference !== undefined;
    }
    setSkipNode(node) {
        this.skipNode = node;
        return this;
    }
    getSkipNode() {
        return this.skipNode;
    }
}
exports.Context = Context;
//# sourceMappingURL=NodeParser.js.map