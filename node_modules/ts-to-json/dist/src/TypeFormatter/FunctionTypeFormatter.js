"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionTypeFormatter = void 0;
const BaseType_1 = require("../Type/BaseType");
const FunctionType_1 = require("../Type/FunctionType");
const UndefinedType_1 = require("../Type/UndefinedType");
const UnionType_1 = require("../Type/UnionType");
const allOfDefinition_1 = require("../Utils/allOfDefinition");
class FunctionTypeFormatter {
    constructor(childTypeFormatter, config) {
        this.childTypeFormatter = childTypeFormatter;
        this.config = config;
    }
    supportsType(type) {
        return type instanceof FunctionType_1.FunctionType;
    }
    getDefinition(type) {
        if (type.getBaseTypes().length === 0) {
            return this.getObjectDefinition(type);
        }
        return type
            .getBaseTypes()
            .reduce((0, allOfDefinition_1.getAllOfDefinitionReducer)(this.childTypeFormatter), this.getObjectDefinition(type));
    }
    getChildren(type) {
        const parameters = type.getParameters();
        const additionalParameters = type.getAdditionalParameters();
        const returnTypes = type.getReturnType();
        return [
            ...this.childTypeFormatter.getChildren(returnTypes),
            ...type
                .getBaseTypes()
                .reduce((result, baseType) => [
                ...result,
                ...this.childTypeFormatter.getChildren(baseType).slice(1),
            ], []),
            ...(additionalParameters instanceof BaseType_1.BaseType
                ? this.childTypeFormatter.getChildren(additionalParameters)
                : []),
            ...parameters.reduce((result, parameter) => [
                ...result,
                ...this.childTypeFormatter.getChildren(parameter.getType()),
            ], []),
        ];
    }
    getReturnType(type) {
        const parameters = type.getParameters();
        const additionalParameters = type.getAdditionalParameters();
        return [
            ...type
                .getBaseTypes()
                .reduce((result, baseType) => [
                ...result,
                ...this.childTypeFormatter.getChildren(baseType).slice(1),
            ], []),
            ...(additionalParameters instanceof BaseType_1.BaseType
                ? this.childTypeFormatter.getChildren(additionalParameters)
                : []),
            ...parameters.reduce((result, parameter) => [
                ...result,
                ...this.childTypeFormatter.getChildren(parameter.getType()),
            ], []),
        ];
    }
    getObjectDefinition(type) {
        const objectParameters = type.getParameters();
        const required = objectParameters
            .map((parameter) => this.prepareObjectParameter(parameter))
            .filter((parameter) => parameter.isRequired())
            .map((parameter) => parameter.getName());
        const parameters = objectParameters
            .map((parameter) => this.prepareObjectParameter(parameter))
            .reduce((result, parameter) => ({
            ...result,
            [parameter.getName()]: this.childTypeFormatter.getDefinition(parameter.getType()),
        }), {});
        const def = this.childTypeFormatter.getDefinition(type.getReturnType());
        const anyParam = Object.keys(parameters).length;
        return {
            kind: "function",
            ...(def.type
                ? def
                : {
                    properties: def,
                }),
            ...(Object.keys(parameters).length > 0 ? { parameters } : {}),
            ...(anyParam ? { required } : {}),
        };
    }
    prepareObjectParameter(parameter) {
        const propType = parameter.getType();
        if (propType instanceof UndefinedType_1.UndefinedType) {
            return new FunctionType_1.FunctionParameter(parameter.getName(), new UndefinedType_1.UndefinedType(), false);
        }
        else if (!(propType instanceof UnionType_1.UnionType)) {
            return parameter;
        }
        const requiredTypes = propType.getTypes().filter((it) => !(it instanceof UndefinedType_1.UndefinedType));
        if (propType.getTypes().length === requiredTypes.length) {
            return parameter;
        }
        else if (requiredTypes.length === 0) {
            return new FunctionType_1.FunctionParameter(parameter.getName(), new UndefinedType_1.UndefinedType(), false);
        }
        return new FunctionType_1.FunctionParameter(parameter.getName(), requiredTypes.length === 1 ? requiredTypes[0] : new UnionType_1.UnionType(requiredTypes), false);
    }
}
exports.FunctionTypeFormatter = FunctionTypeFormatter;
//# sourceMappingURL=FunctionTypeFormatter.js.map